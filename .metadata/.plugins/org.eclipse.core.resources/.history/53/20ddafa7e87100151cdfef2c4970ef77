import lejos.hardware.Brick;
import lejos.hardware.BrickFinder;
import lejos.hardware.Key;
import lejos.hardware.KeyListener;
import lejos.hardware.lcd.LCD;
import lejos.hardware.motor.NXTRegulatedMotor;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.NXTTouchSensor;
import lejos.hardware.sensor.NXTUltrasonicSensor;
import lejos.utility.Delay;

public class PID_Part3 {
	static NXTUltrasonicSensor ultra = new NXTUltrasonicSensor(SensorPort.S2);
	// static NXTLightSensor light = new NXTLightSensor(SensorPort.S3);
	static NXTTouchSensor touch = new NXTTouchSensor(SensorPort.S1);
	// static NXTSoundSensor sound = new NXTSoundSensor(SensorPort.S4);
	static private int distance, leftD, rightD;
	
	static Brick brick = BrickFinder.getDefault();
	static NXTRegulatedMotor left = new NXTRegulatedMotor(brick.getPort("A"));
	static NXTRegulatedMotor right = new NXTRegulatedMotor(brick.getPort("B"));
	
	static globalData touchedData = new globalData(); 
	static globalUltrasonicData sonicData = new globalUltrasonicData();


	//public static boolean finish = false;
	
	public static void main(String[] args) {
		
		final int desiredDistance = 10;

		// initialize PID constants
		final double Kp = .8;
		final double Ki = 0.000001;
		final double Kd = 2;

		// unaltered turn power
		final int Tp = 200;

		double error;
		double accumError = 0;
		double lastError = 0;
		double errorDiff;
		int distance;
		
		 brick.getKey("Escape").addKeyListener(new KeyListener() {
		     
             public void keyPressed(Key k) {
 				left.stop(true);
 				right.stop();
        
     				left.close();
     				right.close();
     				
                     System.exit(1);
             }

     
             public void keyReleased(Key k) {
 				left.stop(true);
 				right.stop();
             	
 				left.close();
 			
 				right.close();
                 System.exit(1);
             }
     });
		
		left.setSpeed(Tp);
		right.setSpeed(Tp);
		left.forward();
		right.forward();
		while(true){
			distance = sonicData.getSonicValue();
			if(distance>30){
				double wheelCircunference = wheelDiameter * Math.PI;
				left.flt(true);
				right.flt();
				Delay.msDelay(2000);
				int Tp = 100;
				left.setSpeed(Tp);
				right.setSpeed(Tp);
				left.rotate(150,true);
				right.rotate(150);
				Delay.msDelay(2000);
					//Sound.systemSound(true, 3);
					
				int degrees=(int)Math.round((((robotTrack*Math.PI)/8)/wheelCircunference)*360.0);
				//Part5_main.left.startSynchronization();
				left.rotate((int)(degrees+30),true);
				right.rotate((int)(-degrees-30));
				//Part5_main.left.endSynchronization();
				left.waitComplete();
				right.waitComplete();
				Delay.msDelay(2000);
				left.rotate(400,true);
				right.rotate(400);
				left.waitComplete();
				right.waitComplete();
				left.forward();
				right.forward();
			}
			else{
				distance = sonicData.getSonicValue();
				LCD.drawString(Integer.toString(distance), 0, 0);
			
					error = distance - desiredDistance;
				accumError += error;
				errorDiff = error - lastError;
				lastError = error;
				if (errorDiff >= 30 || accumError>=30){
					errorDiff = 0;
					accumError = 0;
				}
					// set PID values
				double P = Kp * error;
				double I = Ki * accumError;
				double D = Kd * errorDiff;
	
				double turn = P + I + D;
				
				int upPower = (int) (Tp + turn);
				int downPower = (int) (Tp - turn);
				if (error > 0) {
					left.setSpeed(upPower);
					right.setSpeed(downPower);
					}
				else if(error<0) {
					right.setSpeed(downPower);
					left.setSpeed(upPower);
					}
				left.forward();
				right.forward();
			
		}
		}
		
	
}
	}